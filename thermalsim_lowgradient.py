#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Feb 19 12:59:01 2018

@author: peter

Thermal model of an 18650 battery heating during two-step charging
Peter Attia, February 19, 2018

Inputs:
- C1, C2: Numerical values of the first and second C rates of the two-step policy
- show_plot: Boolean if a temperature profile plot should be displayed
- variance: Boolean if the returned lifetime should have noise added to it

Outputs:
- Lifetime (arb. units)

Reference: http://cecs.wright.edu/~sthomas/htchapter02.pdf
Equation 2-26

This simulation uses finite differences to approximate the heat equation.

Assumptions:
    Long cylinder (R/L = 0.14)
    Heat transfer through SS can is fast (for can, T_in = T_out)

Initial condition:
    T(t=0,r) = T_init

Boundary conditions:
    (1) dT/dr(t,r=0) = 0 (symmetry at cylinder centerline)
    (2) -k(dT/dr)|(r=R) = h(T(t=0,R) - T_env) (convection)

NOTE: BC (1) reduces to constant temperature case (T(t,x=R) = T_init)
if h is large
"""

import math
import random
import numpy as np
import matplotlib.pyplot as plt

def thermalsim(C1, C2, show_plot = False, variance = True):

    # STANDARD DEVIATION
    if variance:
        sigma = np.std([495, 461, 471]) # batch2 baseline policy
    else:
        sigma = 0

    # DETERMINE SOC1
    chargetime = 10 # [=] minutes
    if C1 == C2:
        SOC1 = 80
    else:
        SOC1 = 100 * ( chargetime - (60*0.8/C2) ) / (60/C1 - 60/C2)
    # print('SOC1 = ' + '{:.1%}'.format(SOC1/100))

    # CONSTANT PARAMETERS
    R = 0.009              # [=] m, radius of 18650 cylindrical cell
    L = 0.065              # [=] m, length of 18650 cylindrical cell
    R_int = 0.017          # [=] Ohms, internal resistance
    Tinit = 30             # [=] deg C, initial temperature
    Tinf  = 30             # [=] deg C, environmental temperature
    V = math.pi * R**2 * L # [=] m^3, cell volume

    # ESTIMATED PARAMETERS
    # Values for k, Cp, and rho from Drake et al, JPS (2014)
    # http://www.uta.edu/faculty/jaina/MTL/pubs/Drake-JPS2014.pdf
    k = 0.20   # [=] W/m-K, thermal conductivity
    Cp = 1000  # [=] J/kg-K, specific heat capacity
    rho = 2362 # [=] kg/m^3, density

    # Value for rho estimated from mass of cell is in good agreement with above
    # value
    # http://www.a123batteries.com/v/vspfiles/images/pdf/APR18650M1A.pdf
    # rho = (39/1000)/V # [=] kg/m^3, average density

    # Value for h taken from Engineering Toolbox: h = 10 for air, 500 for oil
    h = 10 # [=] W/m^2-K, heat transfer coefficient

    # DEGRADATION PARAMETERS. ESTIMATED FROM SMITH, DAHN ET AL 2011
    A = 5e21      # [=] 1/s, pre-exponential constant
    Ea = 0.25    # [=] eV, activation energy
    kb = 8.617E-5 # [=] eV/K, Boltzmann's constant

    # CALCULATED PARAMETERS
    I1 = C1*1.1             # [=] A, C1 discharge current
    I2 = C2*1.1             # [=] A, C2 discharge current
    Q1 = 1.1*SOC1/100       # [=] Ah, capacity filled during C1
    Q2 = 1.1*(80-SOC1)/100  # [=] Ah, capacity filled during C2
    t1 = Q1 / I1 * 3600     # [=] s, time of C1
    t2 = Q2 / I2 * 3600     # [=] s, time of C2
    total_time = t1 + t2;   # [=] s, total time for both C1 and C2 steps
    alpha = k/(rho*Cp)      # [=] m^2/s, thermal diffusivity
    power1 = I1**2 * R_int  # [=] W, power generated by cell during C1
    e_gen1 = power1 / V     # [=] W/m^3, volumetric heat generation term
    power2 = I2**2 * R_int  # [=] W, power generated by cell during C2
    e_gen2 = power2 / V     # [=] W/m^3, volumetric heat generation term

    """"
    --------------------------BEGIN SIMULATION--------------------------
    """

    ## Set up problem
    dr = 0.001 # [=] m, length step
    dt = 20    # [=] s, time step. <2s for minimal error, 5s is reasonable

    N = int(np.round(R/dr + 1))
    r = np.arange(-dr,R+2*dr,dr)
    T = Tinit*np.ones((N+2,1)) # initialize domain to be IC
    #T[N+1,0] = T[N,0]-dr*k*h*(T[N,0]-Tinf) # Env. boundary condition


    # PRE-INITIALIZE VARIABLES
    time = 0
    deg_rates = 0

    def fin_el(Tin, e_gen):
        # FINITE ELEMENT SIMULATION
        mat = np.zeros((N+2,N+2))
        rhs = np.zeros((N+2,1))

        # Internal domain
        for i in np.arange(2,N+1):
            mat[i,i] = (r[i] * dr**2 * dt) * (1/(alpha*dt)+2/(dr**2))
            mat[i,i+1] = (r[i] * dr**2 * dt) * (-1/(2*r[i]*dr)-1/(dr**2))
            mat[i,i-1] = (r[i] * dr**2 * dt) * (1/(2*r[i]*dr)-1/(dr**2))
            rhs[i] = (r[i] * dr**2 * dt) * ( Tin[i,0]/(alpha*dt)+e_gen/k )

        # Boundary condition at r = 0
        mat[0,0] = 1
        mat[0,2] = -1

        # Cartesian singularity at r = 0
        mat[1,1] = (dr ** 2 * dt) * (4/(dr**2))
        mat[1,2] = (dr ** 2 * dt) * ((1/dt - 4/(dr**2)))
        rhs[1]   = (dr ** 2 * dt) * (Tin[1,0]/(dt) + e_gen/k)

        # Boundary condition at r = R
        mat[N+1,N] = -h
        mat[N+1,N+1] = -k/(2*dr)
        mat[N+1,N-1] = k/(2*dr)
        rhs[N+1] = -h*Tinf

        return np.linalg.lstsq(mat,rhs)[0] # T(r)

    ## C1 step
    while time < t1:

        T = fin_el(T, e_gen1)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))

    ## C2 step
    while time < total_time:

        T = fin_el(T, e_gen2)
        time = time + dt

        for Tidx in T:
            deg_rates = deg_rates + A * math.exp(-Ea/(kb*Tidx))

    ## Plot
    if show_plot:
        result = (r, T)
        plt.plot(result[0]*1000,result[1])
        plt.xlabel('Position (mm)'),plt.ylabel('Temperature (deg C)')

    # arbitrary factor to give lifetimes on the order of 100s of cycles
    lifetime_true = int(1/deg_rates/1e10) + 900
    lifetime_meas = int(random.gauss(lifetime_true, sigma))
    if lifetime_meas < 0: lifetime_meas = 1
    # print("Lifetime = " + str(lifetime_meas))
    return lifetime_meas

 ## Exmaple: C1 = 6, C2 = 3
#lifetime = thermalsim(6,3)
